# Ch07. DFS 알고리즘

- 대표적인 그래프 탐색 알고리즘(DFS, BFS). (탐색 = 많은 양의 데이터 중 원하는 데이터를 찾는 과정)

## DFS 이해하기

### DFS는 스택 자료구조를 사용한다.

- 스택 자료구조란? 먼저 들어온 데이터가 나중에 나가는(선입후출)의 자료구조.

```js
let stack = [];

stack.push(1);
stack.push(3);
stack.push(5);
stack.pop();

console.log(stack); // 1 3
```

### 일반적으로 자바스크립트에서 DFS와 같은 그래프 문제를 해결할 때는?

- 2차원 배열(리스트)로 그래프를 표현한다.
- 인접 리스트 표현 방식의 예시는 다음과 같다.

  <img width="300" src="https://github-production-user-asset-6210df.s3.amazonaws.com/101846817/277548960-550c67e9-1c8d-4b17-aea7-a6c201ed577c.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20231026%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20231026T005835Z&X-Amz-Expires=300&X-Amz-Signature=43317e0a7a70da1ba8af4ceccd7d677bcd648ced5c7c7cd88998b88f88e4bb1c&X-Amz-SignedHeaders=host&actor_id=101846817&key_id=0&repo_id=669919145">
<br/>

## 깊이 우선 탐색(DFS)이란?

- 그래프 혹은 트리에서 모든 노드를 한 번씩 탐색하기 위한 기본적인 방법
- [완전 탐색]을 수행하기 위한 가장 간단한 방법 중 하나
- 스택 자료구조를 사용한다.

<br/>

## 깊이 우선 탐색(DFS) 기본 동작 방식

1. 시작 노드를 스택에 넣고 [방문 처리]한다.
2. 스택에 마지막으로 들어온 노드에 방문하지 않은 인접 노드가 있는지 확인한다.
   2-1. 있다면 방문하지 않은 인접 노드를 스택에 삽입하고 [방문 처리]한다.
   2-2. 없다면, 현재 노드(스택에 마지막으로 들어온 노드)를 스택에서 추출한다.
3. 2번 과정을 더 이상 반복할 수 없을 때까지 반복한다.

<br/>

## 깊이 우선 탐색(DFS) 구현 특징

- DFS를 실제로 구현할 때는 스택 혹은 재귀 함수를 이용한다. (재귀 함수는 내부적으로 스택과 동일한 동작 원리를 가지므로, 구현의 편리성이 존재한다.)
- 완전 탐색을 목적으로 하는 경우, 탐색 속도가 BFS보다 느린 경우가 있다.
- 그럼에도 구현의 편리성 때문에 BFS 대신에 사용하는 경우 또한 많다.

<br/>

## 깊이 우선 탐색(DFS) 사용 예시

1. 더 짧은 코드로 간결히 구현해야 하는 경우
2. 큐 라이브러리를 사용할 수 없는 경우
3. 트리의 순회, 점화식 구현 등 DFS(재귀 함수)에 특화된 문제인 경우
4. 트리에서 최단 거리 탐색을 구하는 경우(트리에서는 두 노드를 잇는 경로가 하나만 존재한다.)

## 깊이 우선 탐색(DFS) 동작 방식 예시

- 노드 방문 순서 : A => B => C => E => H => F => D => G

1. 시작 노드를 스택에 넣고 [방문 처리]한다.

   <img width="300"  src="https://github-production-user-asset-6210df.s3.amazonaws.com/101846817/277550293-44065d0c-5770-42c9-a10f-12d66b40b276.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20231026%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20231026T010007Z&X-Amz-Expires=300&X-Amz-Signature=9bbb2f1a49dc59291e7db5436f6961fabeeeb9a69bfad369e1d9ddd7b58e02f6&X-Amz-SignedHeaders=host&actor_id=101846817&key_id=0&repo_id=669919145">
   <br />

2. 최상위 노드 A와 인접한 노드 B를 방문하고, [방문 처리]한다.
3. 최상위 노드 B와 인접한 노드 중 방문하지 않은 노드가 없으므로 추출한다.
4. 최상위 노드 A와 인접한 노드 C를 방문하고, [방문 처리]한다.

   <img width="300" src="https://github-production-user-asset-6210df.s3.amazonaws.com/101846817/277550718-d3f73700-86bf-4eb1-b983-df49f7e19a07.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20231026%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20231026T010233Z&X-Amz-Expires=300&X-Amz-Signature=7c5cc64a9c7ff51ca353b92a40c95605629358bff8d44cce9da5f3b65f3f4a6d&X-Amz-SignedHeaders=host&actor_id=101846817&key_id=0&repo_id=669919145">
    <br />

5. 최상위 노드 C와 인접한 노드 중 방문하지 않은 노드 E를 방문한다.
6. 최상위 노드 E와 인접한 노드 중 방문하지 않은 노드 H를 방문한다.
7. 최상위 노드 H와 인접한 노드 중 방문하지 않은 노드가 없으므로 추출한다.

   <img width="300" src="https://github-production-user-asset-6210df.s3.amazonaws.com/101846817/277550815-2eb59ed2-6a24-4388-813d-59621d61f22d.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20231026%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20231026T010254Z&X-Amz-Expires=300&X-Amz-Signature=5d6137738cfde7c28b6e299b59340125be3b7f8a1b9e67367f1acab676d30de2&X-Amz-SignedHeaders=host&actor_id=101846817&key_id=0&repo_id=669919145">
    <br />

8. 최상위 노드 C와 인접한 노드 중 방문하지 않은 노드 F를 방문한다.
9. 최상위 노드 F와 인접한 노드 중 방문하지 않은 노드가 없으므로 추출한다.
   ... (생략)
   n. 최상위 노드 A와 인접한 노드 중 방문하지 않은 노드가 없으므로 추출한다.

- 실제 알고리즘/코테 문제에서는 노드의 번호가 1부터 시작하는 경우가 많다.
  (최대한 특정 방향으로 깊게 들어갔다 빠져 나오는 방식으로 이해하면 된다.)
  <img width="300" src="https://github-production-user-asset-6210df.s3.amazonaws.com/101846817/277551165-d937151f-866d-4dc4-91f0-aaa6d4da76c5.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20231026%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20231026T010314Z&X-Amz-Expires=300&X-Amz-Signature=54b952536eef3c2170eacab6a46e8ee373bfe51d0492786e64738e72e2cd3cd6&X-Amz-SignedHeaders=host&actor_id=101846817&key_id=0&repo_id=669919145">

## 깊이 우선 탐색(소스코드 예시)

```js
// dfs 메서드 정의(graph, 현재노드 v, 방문처리 여부)
function dfs(graph, v, visited) {
  // 방문한 노드 = 방문 처리
  visited[v] = true;

  // 현재 노드와 연결된 노드(인접한 노드)를 재귀적으로 방문
  for (i of graph[v]) {
    if (!visited) dfs(graph, i, visited);
  }
}

// 각 노드가 연결된 정보를 표현(0번 노드를 빈 배열로 한 이유는 1번 노드부터 직관적으로 보기 위해)
graph = [[], [2, 3, 4], [1], [1, 5, 6], [1, 7], [3, 8], [3], [4], [5]];

// 각 노드가 방문된 정보를 표현
visited = Array(9).fill(false);

// 정의된 dfs 함수 호출
dfs(graph, 1, visited);
```
