# 문제풀이 2

### 1. 숫자카드 2(https://www.acmicpc.net/problem/10816)

```js
let fs = require("fs");
let input = fs.readFileSync("/dev/stdin").toString().split("\n");

let n = Number(input[0]);
let myArr = input[1].split(" ").map(Number);
let m = Number(input[2]);
let yourArr = input[3].split(" ").map(Number);

myArr.sort((a, b) => a - b);

// upperBound - lowerBound = 해당 요소의 갯수

// 가장 왼쪽의 인덱스를 찾음
const lowerBound = (arr, target, start, end) => {
  while(start < end){
    let mid = parseInt((start + end) / 2);
    if(arr[mid] >= target) end = mid;
    else start = mid + 1;
  }
  return end;
}

// 가장 오른쪽의 인덱스를 찾음
const upperBound = (arr, target, start, end) => {
  while(start < end){
    let mid = parseInt((start + end) / 2);
    if(arr[mid] > target) end = mid;
    else start = mid + 1;
  }
  return end;
}

const countByRange = (arr, leftValue, rightValue) => {
  let leftIndex = lowerBound(arr, leftValue, 0, arr.length);
  let rightIndex = upperBound(arr, rightValue, 0, arr.length);
  return rightIndex - leftIndex;
}

let answer = ' ';

for(let i = 0; i < m; i++){
  let count = countByRange(myArr, yourArr[i], yourArr[i]);
  answer += count + ' ';
}

console.log(answer);
```

### 2. 병사 배치하기(https://www.acmicpc.net/problem/18353)

#### 초기 풀이
초기 구상은 이진탐색을 이용하지 않고, 내림차순 형태로 만들어주면 되기 때문에 단순 앞값과 뒷값을 비교해 뒷값이 크면 제외시켜 내림차순 형태로 만드는 방법 구상.
```js
let fs = require("fs");
let input = fs.readFileSync("/dev/stdin").toString().split("\n");

let n = Number(input[0]);
let arr = input[1].split(" ").map(Number);
let answer = [];

for(let i = 0; i < n; i++){
  if(arr[i] < arr[i+1]){
    answer.push(arr[i])
  }
}

console.log(answer.length);
```

#### 강사님 풀이
초기 상태 = 0, 현재 원소가 가장 크다면 삽입, 아니라면 최대한 왼쪽 원소와 교체(lowerBound)

```js
let fs = require("fs");
let input = fs.readFileSync("/dev/stdin").toString().split("\n");

let n = Number(input[0]);
let arr = input[1].split(" ").map(Number);

const lowerBound = (arr, target, start, end) => {
  while(start < end){
    let mid = parseInt((start + end) / 2);
    if(arr[mid] >= target) end = mid;
    else start = mid + 1;
  }
  return end;
}

arr.reverse();

let d = [0];

for(x of arr){
  // 현재 원소 > 마지막 원소, 제일 오른쪽에 추가
  if(d[d.length - 1] < x){
    d.push(x);
  }
  // 현재 원소 < 마지막 원소, target값이 있는 최대한의 왼쪽 인덱스를 찾아 교체
  else {
    let index = lowerBound(d, x, 0, d.length);
    d[index] = x;
  }
}

console.log(n - (d.length - 1));
```

### 3. K번째 수(https://www.acmicpc.net/problem/1300)

```js
let fs = require("fs");
let input = fs.readFileSync("/dev/stdin").toString().split("\n");

let n = Number(input[0]);
let k = Number(input[1]);

let start = 1;
let end = 10 ** 10;

let result = 0;
while(start <= end){
  let mid = parseInt((start+end) / 2);
  let total = 0;
  for(let i = 1; i <=n; i++){
    total += Math.min(parseInt(mid / i), n);
  }
  if(total >= k){
    result = mid;
    end = mid - 1;
  }
  else start = mid + 1;
}

console.log(result);
```