## 3. 그리디 문제 풀이 2

#### 1) 설탕 배달

: https://www.acmicpc.net/problem/2839

#### 내가 푼 풀이

````js
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "/input.txt";
let input = fs
  .readFileSync(__dirname + filePath)
  .toString()
  .split("\n");

let num = Number(input[0]);

// 1. 5로 나누어 떨어지는 경우
// 2. 5로 나누어 떨어지지 않았을때
//    1). 3으로 나누어 떨어지는 경우
//    2). 3과 5를 섞어 나누어 떨어지는 경우(3킬로그램 봉지를 추가로 사용) ex) 11 336
// 3. 3과 5를 설탕 봉지로 만들 수 없는 경우 -1

let cnt = 0; // 가져가는 설탕 봉지 갯수
let n = 0; // 나머지 값을 받을 숫자

if (num % 5 === 0) {
  cnt = num / 5;
} else {
  while (num >= 3 && num % 5 !== 0) {
    num -= 3;
    cnt++;
  }

  if (num % 5 === 0) {
    cnt += num / 5;
  } else {
    cnt = -1;
  }
}

console.log(cnt);

```js

#### 다른 풀이

- 가장 단순하게 생각하자
- 어떤 수를 0으로 만들어야 하는 상황에서 두가지 연산 사용
  - 값에서 5를 빼기
  - 값에서 3을 빼기
- 반복적으로 3을 뺴면서 5로 나누어 떨어질 때를 찾기

- 수학적으로 생각해보기
  -  3A + 5B= N
  - 목표: B가 가장 큰 경우를 찾기

```js
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "/input.txt";
let input = fs
  .readFileSync(__dirname + filePath)
  .toString()
  .split("\n");

let n = Number(input[0]);

let cnt = 0; // 가져가는 설탕 봉지 갯수
let flag = false;

// 3을 반복적으로 빼면서 5로 나누어 떨어질 수 있는지 찾기
while (n >= 0) {
  if (n == 0 || n % 5 == 0) {
    //n이 0으로 3과 5가 나누어 떨어질 때
    cnt += n / 5;
    console.log(cnt);
    flag = true;
    break;
  }
  n -= 3;
  cnt += 1;
}
if (!flag) {
  console.log(-1);
}

````

---

#### 2) A -> B

: https://www.acmicpc.net/problem/16953

#### 내가 푼 풀이

```js
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "/input.txt";
const input = fs
  .readFileSync(__dirname + filePath)
  .toString()
  .split("\n");

const [a, b] = input[0].split(" ").map(Number);

function solve(a, b) {
  let cnt = 0;

  while (b > a) {
    if (b % 10 === 1) {
      b = Math.floor(b / 10);
    } else if (b % 2 === 0) {
      b = b / 2;
    } else {
      // 조건이 만족되지 않는 경우
      break;
    }
    cnt++;
  }

  return b === a ? cnt + 1 : -1;
}

const result = solve(a, b);
console.log(result);
```

#### 다른 풀이

```js
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "/input.txt";
const input = fs
  .readFileSync(__dirname + filePath)
  .toString()
  .split("\n");

let [a, b] = input[0].split(" ").map(Number);
let flag = false;
let result = 1;

while (a <= b) {
  if (a == b) {
    flag = true;
    break;
  }
  if (b % 2 == 0) {
    b = parseInt(b / 2); //2로 나누어 떨어지는 경우
  } else if (b % 10 == 1) {
    // 일의 자릿수가 1인 경우
    b = parseInt(b / 10);
  } else break; // 위 경우가 모두 해당되지 않는 경우
  result++;
}

if (flag) console.log(result);
else console.log(-1);
```

---

#### 3) 수들의 합

: https://www.acmicpc.net/problem/1789

#### 내가 푼 풀이

- 자연수 N의 최댓값 => 1부터 s가 될 때 까지의 합

```js
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "/input.txt";
const input = fs
  .readFileSync(__dirname + filePath)
  .toString()
  .split("\n");

let n = Number(input[0]);

//1부터 계속 더해서 n값까지 더하기

let cnt = 0;
let sum = 0;

while (sum <= n) {
  cnt++;
  sum += cnt;
}

console.log(cnt - 1);
```

#### 다른 풀이

내가 푼 풀이랑 똑같다

---

#### 4) 신입 사원

: https://www.acmicpc.net/problem/1946

#### 내가 푼 풀이

#### 다른 풀이

```js
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "/input.txt";
const input = fs
  .readFileSync(__dirname + filePath)
  .toString()
  .split("\n");

let t = Number(input[0]);
let line = 1; //tc가 여러개이기 때문에 필요함

for (let tc = 0; tc < t; tc++) {
  let n = Number(input[line]); //5
  let arr = [];
  for (let x = line + 1; x <= line + n; x++) {
    let i = input[x].split(" ").map(Number);
    arr.push(i);
  }
  arr.sort((a, b) => a[0] - b[0]);
  let count = 0;
  let minVal = 100001;
  for (let [x, y] of arr) {
    if (y < minVal) {
      minVal = y;
      count += 1;
    }
  }

  console.log(count);
  line += n + 1;
}
```

- 메모
  2중 배열 일 때 arr[i][0], arr[i][1] 보다는 let [x,y]로 구조 분해 할당으로 풀기
