## 3. 그리디 문제 풀이 3

#### 1) 주유소

: https://www.acmicpc.net/problem/13305

#### 내가 푼 풀이

```js
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "/input.txt";
const input = fs
  .readFileSync(__dirname + filePath)
  .toString()
  .split("\n");

let num = Number(input[0]);
4;
let dist = input[1].split(" ").map(Number); // 2 3 1
let cost = input[2].split(" ").map(Number); // 5 2 4 1

// 주유 비용이 최소 일 때 거리 비용도 곱해주기
let minCost = cost[0];
let sum = 0;
for (let i = 0; i < num; i++) {
  if (minCost > cost[i]) {
    minCost = cost[i];
  } else {
    cost[i] = minCost;
  }
  if (dist[i]) {
    sum += dist[i] * cost[i];
  }
}

console.log(sum);
```

58점

#### 다른 풀이

```js
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "/input.txt";
const input = fs
  .readFileSync(__dirname + filePath)
  .toString()
  .split("\n");

let num = Number(input[0]);
let dist = input[1].split(" ").map(Number); // 2 3 1
let cost = input[2].split(" ").map(Number); // 5 2 4 1

// 주유 비용 비오름차순 변환
let minCost = cost[0];
for (let i = 0; i < num; i++) {
  minCost = Math.min(minCost, cost[i]);
  cost[i] = minCost;
}

//도로당 이동 비용의 합 계산
let ans = BigInt(0);
for (let i = 0; i < num - 1; i++) {
  // js에서 큰 정수를 처리 할 때는 BigInt
  ans += BigInt(dist[i]) * BigInt(cost[i]);
}

console.log(String(ans)); // 뒤에 붙는 'n' 제거
```

---

#### 2) 회의실 배정

: https://www.acmicpc.net/problem/1931

#### 내가 푼 풀이

```js
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "/input.txt";
const input = fs
  .readFileSync(__dirname + filePath)
  .toString()
  .split("\n");

let num = Number(input[0]);
let arr = [];
for (let i = 1; i <= num; i++) {
  arr.push(input[i].split(" ").map(Number));
}

//종료 시점이 이른것부터 오름차순 배열
arr.sort((a, b) => {
  if (a[1] != b[1]) {
    return a[1] - b[1];
  } else {
    return a[0] - b[0];
  }
});

// 뒷자리랑 앞자리랑 같은지 확인
let cnt = 1;
let cur = 0;
for (let i = 1; i < num; i++) {
  if (arr[cur][1] <= arr[i][0]) {
    cur = i;
    cnt += 1;
  }
}

console.log(cnt);
```

#### 다른 풀이

내가 푼것과 유사

---

#### 3) 풍선 맞추기

: https://www.acmicpc.net/problem/11509

#### 내가 푼 풀이

- 문제 풀이 아이디어 : 배열을 반복하며 연속적인 숫자가 나오면 제거
  로직 구현 실패

#### 다른 풀이

```js
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "/input.txt";
const input = fs
  .readFileSync(__dirname + filePath)
  .toString()
  .split("\n");

let arr = input[1].split(" ").map(Number); // [ 2, 1, 5, 4, 3 ]
let res = 0;

let arrow = new Array(1000001).fill(0); // 각 높이에 화살이 몇개 있는지 배열 생성
for (let x of arr) {
  if (arrow[x] > 0) {
    //해당 높이에 화살이 있다면
    arrow[x] -= 1;
    arrow[x - 1] += 1;
  } else {
    //해당 높이에 화살이 없다면
    arrow[x - 1] += 1;
    res += 1;
  }
}

console.log(res);
```

- 초기에 모든 높이에 대해서 배열을 생성한 후,
  배열에 값이 없으면 화살 생성 , 배열에 값이 있으면 화살 생성 x

---

#### 4) 피보나치

: https://www.acmicpc.net/problem/9009

#### 내가 푼 풀이

실패 !

#### 다른 풀이

```js
const fs = require("fs");
const filePath = process.platform === "linux" ? "/dev/stdin" : "/input.txt";
const input = fs
  .readFileSync(__dirname + filePath)
  .toString()
  .split("\n");

let num = Number(input[0]);

// 피보나치 수열 배열
let pibo = [];
pibo.push(0);
pibo.push(1);
while (pibo[pibo.length - 1] < 1e9)
  pibo.push(pibo[pibo.length - 2] + pibo[pibo.length - 1]);

for (let tc = 1; tc <= num; tc++) {
  let n = Number(input[tc]);
  let res = [];
  let i = pibo.length - 1; // 가장 큰 피보나치 수의 인덱스
  while (n > 0) {
    // n이 0이 될 때 까지
    if (n >= pibo[i]) {
      // 가능한 큰 피보나치 수부터 빼기
      n -= pibo[i];
      res.push(pibo[i]);
    }
    i--;
  }
  let ans = "";
  for (let i = res.length - 1; i >= 0; i--) ans += res[i] + " "; //오름차순
  console.log(ans);
}
```
